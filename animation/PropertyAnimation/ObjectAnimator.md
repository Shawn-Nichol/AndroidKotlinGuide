# ObjectAnimator

This subclass of ValueAnimator provides support for animating properties on a target object. The constructors of this class take parameteres to define the targe object that will be animated as well as the name of the property that will be animated. Approperiate set/get functions are then deteremined interenally and the animation will call these functions as necessary to animate the property.

## Instanate
ObjectAnimator is similar to a ValueAnimatoe, but you specify the object and the name of that object property(as a string) along with the values to animate. 
```
val animate = ObjectAnimator.ofFloat(textView, "traslationX", 100f).apply {
  duration = 1000
  start()
}
```

## Update properties
To have the ObjectAnimator update properties correctly you must 
- The object requires a setter function. Becuase the ObjectAnimator automatically updates the property during animation you must be able to access the it through the setter method. 
```
  setFoo()
```
If there is no setter you have three options. 
  - Add a setter method to the class. 
  - Use a wrapper class and receive the value with a valid setter method and forwardit to the orignial object.
  - Use a ValueAnimaotr instead. 
  
- If you specify only one value of the values... parameter in one of the ObjectAnimator factory methods, it is assumed to be the ending value of the animation. Therefore, the object property that you are animating must have a getter function that is used to obtain the starting values of the animation. 
```
  getFoo()
```

The getter(if needed) and setter methods of the proepty that you are animating must operate on the same type as the starting and ending values that you specify to ObjectAnimator. For example, you must have targetObject.setProperNmae(float and targetObject.getPropName() if you construct the following ObjectAnimator. 
```
ObjectAnimator.ofFloat(targetObject, "propName", 1f)
```

- Depending on what property of object you are animating, you might need to call the invalidate() on a view to force the screen to redraw itself with the updated animated values. You do this in the onAnimationUpdate() callback. For eaxmple, animating the color property of a drawable object only causes updates to the screen when that object redrarws itself. All of the property setters on the View, such as setAlpha() and setTranslationX() invalidate the View properly, so you do not need to invalidate the View when calling theses methods with new values. For more information on listeners, see the section about Animation Listeners. 

## AnimatorSet Choregraph multiple animations. 
The android system lets you bundle animations together into a an AnimatorSet, so that you can specify whether to start animations simultaneously, sequentially, or after a specified delay, You can also nest AnimatorSet objects within each other. 

```
val bouncer = AnimaotrSet().apply {
    play(bounceAnim).before(squashAnim1)
    play(squashAnim1).with(squashAnim2)
    play(squashAnim1).with(stretchAnim1)
    play(squashAnim1).with(stretchAnim2)
    play(bounceBackAnim).after(stretchAnim2)
}

val fadeAnim = ObjectAnimator.ofFloat(newBall, "alpha", 1f, 0f).apply {
    duration = 250
}
AnimatorSet().apply {
    play(bouncer).before(fadeAnim)
    start()
}
```

## Animation Listeners
Listen for important events. 
- Animator.AnimatorListener
  - onAnimationStart() - called when the animation starts. 
  - onAnimationRepeat() - called when the animatino repeates itself
  - onAnimationCancel()  - called when the animatino is canceled. A cancelled animation also call onAnimationEnd
  
- ValueAnimator.AnimatorUpdateListener
  - onAnimationUpdate() - is called on every frame of the animation. Listen to this event to use the calculated values generated by ValueAnimator during an animation. 
  To use the value, query the valueAnimator object passed into the event to get the current animated value with the getAnimatedValue() method. Implementing the 
  listener is requried if you use ValueAnimator. 
  
Depending on what property or object you are animating, you might need to call invalidate() on a View to force that area of the screen to redraw itself with the new animated values. For example, animating the color property of a Drawable object only causes updates to the screen when that object redraws iself. All of the propety setters on View, such as setAlpha and setTranslationX() invalidate the View propertly, so  you don't need to invalidate the View when calling these methods with new values. 
  
You can extend the AnimatorListenerAdapter class instead of implementing the Animator. AnimatorListener interface, if you do not want to implement all of the methods of the Animator. AnimatorListener interface. The animatorListenerAdapetyer class provides empty implementiations of the methods that you can choose to override

Ex, the folowing code creates a AnimatorListenerAdapter for just eh onAnimationEnd() callback. 

```
ObjectAnimator.ofFloat(newBall, "alpha", 1f, 0f).apply {
  duration = 250
  addListener(object : AnimatorListenerAdapter() {
    override fun onAnimationEnd(animation: Animator) {
      balls.remove((animation as ObjectAnimator).target)
    }
  }
}
```

## Animate layot changes to ViewGroup objects
The property animation system provides the capability to animate changes to ViewGroup objects as well a provide an easy way to animate View Objects. 
You can animate layout changes with a ViewGroup with the LayoutTransition class. Views inside a ViewGroup can go through a appearing and disappearing animation when you add them to or remove them from a ViewGroup or when you call a View's setVisibility with VISIBLE, INVISIBLE, or GONE. The remaining Views in the ViewGroup can also animate into their new positions when you add or remove Views. You can define the following animation in a LayoutTransition object by calling setAnimator() and passing in an Animator obejcet with one of the following LayoutTransistion constants.
- appearing: a Flag indicating the animation that runs on items that are appearing in the container. 
- CHANGE_APPEARING: A flag indicating the animation that runs on items that are changing due to a new item appearing in  the container. 
- DISAPPEARING: A flag indicating the animation that runs on items that are dispapearing from the container
- CHANGE_DISAPPEARING: A flag indicating the animation that runs on items that are changing due to an item disappearing from the container. 

You can define your own custom animations for these four types of events to customize the look of your layout transistions or just tell the animation system to use the default animations. 

The LayoutAnimationByDefault and its corresponnding layout_animations_by_default.xml layout resource file show you how to enable the default layout transistions for ViewGroups in XML. The only thing that you need to do is to set the android: animateLayoutchanges attribute to true for the ViewGroup. For example
```
<LinearLayout
    android:orientation="vertical"
    android:layout_width="wrap_content"
    android:layout_height="match_parent"
    android:id="@+id/verticalContainer"
    android:animateLayoutChanges="true" />
```

setting this attribute to true automatically animates Views that are added or removved from the ViewGroup as well as the remaing Views in the VieewGroup. 

## Animate view state chagnes using StateListAnimator
The StateListAnimator class lets you define animators that run when the state of a view changes. This object behaves as a wrapper for an Animator object, calling that animation wheneverr the specified view state(such as "pressed" or "focused") changes. 

The StateListAnimator can be defined in an XML resource with a root <selector> element and child<item> elements that each specify a different view state defined by the StateListAnimator class. Each<item> contains the definition of a preoprty animation set. 
  
  Ex changes the x and y scale of the view ehen it's pressed

```
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- the pressed state; increase x and y size to 150% -->
    <item android:state_pressed="true">
        <set>
            <objectAnimator android:propertyName="scaleX"
                android:duration="@android:integer/config_shortAnimTime"
                android:valueTo="1.5"
                android:valueType="floatType"/>
            <objectAnimator android:propertyName="scaleY"
                android:duration="@android:integer/config_shortAnimTime"
                android:valueTo="1.5"
                android:valueType="floatType"/>
        </set>
    </item>
    <!-- the default, non-pressed state; set x and y size to 100% -->
    <item android:state_pressed="false">
        <set>
            <objectAnimator android:propertyName="scaleX"
                android:duration="@android:integer/config_shortAnimTime"
                android:valueTo="1"
                android:valueType="floatType"/>
            <objectAnimator android:propertyName="scaleY"
                android:duration="@android:integer/config_shortAnimTime"
                android:valueTo="1"
                android:valueType="floatType"/>
        </set>
    </item>
</selector>
```

To attach the state list animator to a veiw, add the android:stateListAnimaotr attribute
```
<Button 
  android:stateListAnimator="@xml/anaimate_scale"
  .../>
```

Or instead assign a state list animator to a view in your code, use the AnimatorInflate.loadStateListAnimator() method, and assign the animator to your view with the View.setStateListaAnimator(). 

Or instead of animationg properties of the view, you can play a drawable animation between state changes, using AnimatedStateListDrawable. Some of the system widgets in Android 5.0 use these aniamtions by default. The following example shows how to define an AniamtedStateListeDrawable as an XML resource

```
<!-- res/drawable/myanimstatedrawable.xml -->
<animated-selector
    xmlns:android="http://schemas.android.com/apk/res/android">

    <!-- provide a different drawable for each state-->
    <item android:id="@+id/pressed" android:drawable="@drawable/drawableP"
        android:state_pressed="true"/>
    <item android:id="@+id/focused" android:drawable="@drawable/drawableF"
        android:state_focused="true"/>
    <item android:id="@id/default"
        android:drawable="@drawable/drawableD"/>

    <!-- specify a transition -->
    <transition android:fromId="@+id/default" android:toId="@+id/pressed">
        <animation-list>
            <item android:duration="15" android:drawable="@drawable/dt1"/>
            <item android:duration="15" android:drawable="@drawable/dt2"/>
            ...
        </animation-list>
    </transition>
    ...
</animated-selector>
```

## Use a Type Evaluator
If you want to animate a type that is unkown to the Android system, you can create your own evaluator by implementing the TypeEvaluator interface. The types that are known by the Android system are int, float, or a color, which are supported by the IntEvaluator, FloatEvaluator, and ArgbEvaluator.

There is only one method to implement in the TypeEvaluator interface, the evaulate();. This allows the animator that you are using to return a appropriate value for your animated property at the current point of the animation. The FloatEvaluator class demonstrates how to do this. 

```
private class FloatEvaluator : TypeEvaluator<Any> {
  override fun evaluate(fraction: Float, startValue: Any, endValue: Any): Any {
    return (startValue as Number).toFloat().let { startFloat -> 
      startFloat + fraction * ((endvalue as Number).toFloat() - startFloat)
  }
}
```

When ValueAnimator runs, it calculates a current elapsed fraction of the animation(a value betwee 0 and 1) and then calculates an interpolated version of that dpeending on what interpolator that you are using. The interpolated fraction is what your TypeEvaluator receives through the fraction parameter, so you don't have to take into account the interpolator when calculating animated values. 


## Interpolators

An interpolator define how specific values in an animation are calculated as a function of time. For example, you can specify animations to happen linearly across the whole animaition, meaning the animation moves evenly the entire time, or you can specify animations to use non-linear time, for example, using acceleration or deceleration at the beginning or end of the animation

Interpolators in the animations system receive a fraction from Animators that represent the elapsed time of the animation. Interpolators modify this fraction to coincide with the type of animation that it aims to provide. The android system provides a set of common interpolators in the android.view.animation package. If none of these suit your needs, you can implement the TimeInterpolator interface and create your own. 

LinearInterpolator has no effect on the elapsed fraction. The accelearateDecelerateInterpolator accelerates into the animation and decelerates out of it. 

## KeyFrames
A keyframe object consist of a time/value pair that lets you define a specific state at a specific time of an animation. Each keyframe can also have its own interpolator to control the behavior of the animation in the interval between the preious keyframes' time and the time of this keyframe. 

To instantiate a Keyframe object, you must ues one of the factory methods, ofInt(), ofFloat(), or ofObject() to obtain the appropriate type of Keyframe. You then call the ofKeyframe() factory method to obtain a PropertyValuesHolder object. Once you have the object, you can obtain an animator by passing the PropertyValuesHolder object and the object to animate. 

```
val kf0 = Keyframe.ofFloat(0f, 0f)
val kf1 = Keyframe.ofFloat(.5f, 360f)
val kf2 = Keyframe.ofFloat(1f, 0f)
val pvhRotation = PropertyValuesHolder.ofKeyframe("rotation", kf0, kf1, kf2).apply {
  duration = 5000
}
```





