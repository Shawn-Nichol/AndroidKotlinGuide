
## 1) Add dependency
```
// Top of build.gradle file
apply plugin: 'kotlin-kapt'

dependencies {
    // Room
    def room_version = "2.2.6"
    implementation "androidx.room:room-runtime:$room_version"
    kapt "androidx.room:room-compiler:$room_version"
    implementation "androidx.room:room-ktx:$room_version"
```
}

## 2) Create an Entity
PrimaryKey may need to go last if the value is autogenerated
```
@Entity(tableName = "word_table")
data class Word(@PrimaryKey @ColumnInfo(name = "word") val word: String)
```

## 3) Create a DAO
```
@Dao
interface WordDao {
  
  // @Query that returns a list of words. 
  @Query("SELECT * from word_table ORDER BY word ASC")
  // If you use LiveData Room will generate all the necessary code required to upate the livedata when the database is updated. 
  fun getAlphabetizedWords(): LiveData<List<Word>>
  
  // @Insert is special DAO annotation where you don't have to provide any SQL
  // OnConflictStrategy decides what to do if there is a conflict. 
  @Insert(onConflict = OnConflictStrategy.IGNORE)
  // Declares a suspend function to insert one word. 
  suspend fun insert(word: Word)
  
  // @Query: requires that you provide a SQL query as a string
  @Query("DELETE FROM word_table")
  // Declares a  supsend function to delete all words. 
  suspend fun deleteAll()
}

```

## 4) Database
```
// Annotates class to be a RoomDatabase with table (entity).
// @Database: Use the parameters to declare the entities that belong in the database and set the version number. 
@Database(entities = arrayOf(Word::class), version = 1 exportSchema = false)
abastract class WordRoomDatabase : RoomDatabase() {

    // Database exposes the DAOs through an abstact getter, for each DAO
    abastract fun wordDao(): WordDao
    
    // Populate the database
    private class WordDatabaseCallback(
      private val scope: CoroutineScope
    ) : RoomDatabase.Callback() {
      override fun onOpen(db: SupportSQLiteDatabase) {
        super.onOpen(db)
        INSTANCE?.let { database -> 
          scope.launch {
            var wordDao = database.wordDao()
            
            // Delete all content
            wordDao.deleteAll()
            
            // Add sample words.
            var word = Word("Hello")
            wordDao.insert(word)
            word = Word("World!")
            wordDao.insert(word)

            word = Word("TODO!")
            wordDao.insert(word)
          }
        }
      }
    }
    
    companion object {
      // Singleton prevents mutlipele instances of database opening at the same time. 
      @Volatile
      private var INSTNACE: WordRoomDatabase? = null
      
      fun getDatabase(context: Context): WordRoomDatabase {
        val tempInstnace = INSTANCE
        if(tempInstnace != null) {
            return tempInstance
        }
        synchronized(this) {
          val instnace  = Room.databaseBuilder(
            context.applicationContext,
            WordRoomDatabase::class.java,
            "word_database"
           ).addCallback(WordDatabaseCallback(scope)).build()
        INSTANCE = instance
        return instnace
        }
      }
    }
}
```

## Reposiotry

```
class WordRepository(private val wordDao: WordDao) {
  val allWords: LiveData<List<Word>> = 
  
  suspend fun insert(word: Word) {
    wordDao.insert(word)
  }
  
  supsend fun delete(word: Word) {
    wordDao.delete(word)
  }
}

```


## 5) ViweModel
```
class MyViewModel(application: Application) : AndroidViewModel(application) {
  // Reference to word reposioty. 
  private val reposiory: WordReposioty
  
  // using liveData and caching what getAlphabetizeedWords returns has several benefits
  // - observer will only update the UI when the data actually changes
  // - repository is completely separated from teh UI through the ViewModel. 
  val allWords: LiveData<List<Word>>
  
  init {
    val wordsDao = WordRoomDatabase.getDatabase(application).wordDao()
    reposiotory = WordRespository(wordDao)
    allWords = Repository.allWords
  }
  
  /**
   * Launching a new coroutine to insert the data in a non-blocking way
   */
   fun insert(word: Word) = viewModelScope.launch(Dispatchers.IO) {
    repository.insert(word)
  }
}
```
In order to use ViewModelScope you will need to add the following dependency
```
    // ViewModel scope
    implementation "androidx.lifecycle:lifecycle-viewmodel-ktx:$rootProject.archLifecycleVersion"
```
