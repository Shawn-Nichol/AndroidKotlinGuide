# Guide to app architecture

## Mobile apps and user experinces
In the majority of cases, desktop apps have a single entry point from  a desktop or program launcher, then run as a single, monolithic process. Android apps, on the other hand, have a much more complext structure. A typical android app contians multiple app components, including activites, fragments, services, content providers and broadcast receivers. 

You declare mos of thesse app components in your app  manifest. The android OS then uses this file to decid ehow to integrate your app into the devices' overall user experince. Given that a properly written android app contains multiple components and that users often interact with multiple apps in a short peroid of time, apss need to adapt to different kinds of user-driven workflows and tasks. 

For example, consider what happens when you share a photo in your favorite social networking app:
1)The app triggers a camera intent. The android OS then launches a camera app to handle the request. At this point, the user has left the social networking app, but their experience is stilll seamless. 
2) The camera app might trigger other intents, like launching the file chooser, which may launch yet another app. 
The camera app might trigger other intents, likelauchning the file chooser, which may launch yet another app. 
3) Eventaully the user returns to the soical networkingn app and shares the photo. 

At any point during hte process, theuser could be interrupted by a phone call or notification. After acting upon the intrruption, the user expects to be able to return to and resume, this photo-sharing process. This app-hopping behavior is common on mobile devices, so your app must handle these flows correctly. 

Keep in mind that mobile devices are also resource-constrained, so at any time, the operating system might kill some app rpocesses to make room for new ones. 

Given the condititions of thiss environment, it's possible for your app components to be launched individually and out-of-ordder, and the oOS or user can destory them at any time. Becuase these events aren't under your control, you shouldn't store any app data or state in your app components, and your app components dhouldn't depend on each other. 


## Common architectural principles
If you shouldn't use app componoents to store app data and state, how should you design your app?

### Seperation of concerns
The most important principle to follow is seperation of concnerns. Its a common mistake to write all your code in an activity or fragment. These UI-based classes should only contain logice that handles UI and operating system interactions. By keeping these classes as lean as possible, you can avoid many lifecycle-rleated problems. 

Keep in mind that you don't own implmementations of Activity and Fragments; rather these arfe just glue classes that represent the contract between teh Android OS and your app. The OS can destroy them at any time based on user interactions or becuase of system conditions like low memory. To provide a satisfacotyr user experince and a more manageable app maintenance experince, it's best to minimize your dependency on them. 

## Drive UI from a model
Another important principle is that you should drive your UI from a model, preferably a persistent model. Models are components that are responsible for handling the data for an app. They're independent from the View objects and app compoonents in your app, so they're unaffected by the app's lifecycle and associated concerns. 

Persistence is ideal for the following reasons
- Your users don't lose data if the Android OS destorys your app to free up resources. 
- Your app continues to work in cases when a network connection is flaky or not available. 
By basing your app on model classes with the well-defined responsibility of managing the data, your app is moretestable and consisten. 

## Recommend app architecture
In this section, we demonstrate how to structurae an app using architectture components by working through an end-to-end use case. 

Note: It's impossible to have one way of writing apps that works best for every scenario. That being said, this recommended architecture is a good starting point for most situations and workflows. If you already have a good way of writing Android apps that follows the common architectural principles you don't need to change it. 

## Build the userinterface
The UI consists of a fragment, UserPRofileFragment, and its corresponding layout file, user_profile_layout.xml
To drive the UI, our data model needs tohold the following data elements. 
- User ID: The identifier for the user. It's best to pass thsi information into the fragment using the fragment arguments. If the Android OS destroys our process, this information is preserved, so the ID is available the next time our app is restarted. 
- User Object A data calss that holds details about the user. 

We use a UserProvileViewModel, based on the ViewModel architecture component, to keep this information. 

A ViewModel object provides the data for a specific UI component, such as a fragment or activity, and contains data-hanlding business logic to  communicate with the  model. For example, the ViewModel can call other components to load the data, and it can foward user requests to modify the data. The ViewModel doesn't know about UI components, so it isn't affected by confiuration changes, such as recreating an activity whenrotating the device. 

We've now defined the following files  
- user_provile.xml.: The UI layout definitino for the screen 
- UserProfileFragmetn: The UI controller that displays the data. 
- UserProfileViewMOdel: The class that prepares the data for viewing in the UserProfileFragment and reacts to user interactions. 

The followoing code snippets show the starting contents for these files. The layout files is moitted for simplicity. 

Now that we have these code modules, how do we connect them? After all, when the user filed is set in the UserProfileViewModel class, we need a way to ifnorm the UI. 

To obtain the user, our VIewModel needs to access the fragment arguments. We can either pass them from the fragment or better, useing the savedState module we can make our ViewModel read the arguemtn directly. 
