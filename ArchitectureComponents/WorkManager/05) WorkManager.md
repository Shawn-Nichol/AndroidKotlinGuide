## Workmanager
The last step is to submit the WorkRequest to WorkManager.  The exact time that worker is going to be executed depenends on the constraints that are used in the WorkRequest and on system optimization. WorkManager is desgned to give the best behavior under these restrictions

```
WorkManager
  .getInstance(myContext)
  .enqueue(workRequest)
```

### Unique Work
Unique work guarantess that you only have one instance of work with a particular name at a time. Unique names are human readable and specified by the developer instead of being auto-generated by WorkManager. Unlike tags, unique names are only associated with a singlle instance of work

Unique work can be applied to one-time and periodic work. You can createa unique work sequence by calling one of thesee methods, dpending on whether you're scheduling repeating work one-time work. 
- WorkManager.enqueueUniqueWork: one-time
- WorkManager.enqueuUniquePeriodicWork(): for periodic work

Both methods acccept 3 arugments
- uniqueWorkName: a string used to uniquely identify the work request
- existingWorkPolicy: a enum which tells WorkManger what to do it there's already an unfinsihed chain of work with that unique name. 
- work: the WorRequest to schedule

```
val sendLogsWorkRequest = 
  PeriodicWorkRequestBUilder<SendLogsWorker>(24, TimeUnit.HOURS)
    .setCOnstraints(constraints)
    .build()
    
WorkManager.getInstance(this).enqueuUniquePeriiodicWork(
  "sendLogs"
  ExistingPeriodicWorkPolicy.KEEP,
  sendLogsWorkRequest
)
```
If the code runs while a sendLogs job is already in the queue, the existin gjob is kept and no new job is added. Unique work sequences can also be useful if you ened to gradually build up a long chain of tasks. For example  a photo editing app might let users undo a long chain of actions. Each of those undo operatiion might take a while, but they have to be performed in teh correc order. In this case, the app could create an undo chain and append each undo operation to the chain as neede

###Conflit resolution 
When scheduling unique work, you must tell Workmanager what action to take when there is a conflict. You do this by passing an enum when enquing the work. 

For one-time work, you provide an Existing WOrkPolicy, which support 4 options for hanlding the conflict. 
- Replace: existing work with the new work, this cancels the existing work. 
- Keep: existing work and ignore the new work. 
- Append, the new work to the end of the existin work. This policy will cause your new work to be chained to the existin gwork, running after the existing work finishes. 

The existing work becomes a prerequisite to the new work. If the existing work becomes CANCELLED or FAILED, the new work is also CANCELLED or FAILED. If you want the new work to run regardless of the staus of the existing work, use APPEND_ORrEPLACE instead. 
- APPEND_OR_REPLACE function similarly to APPEND, except that it is not dependent on prerequisite work status. If the existing work is CANCELLED or FAILED the new work still runs. 

For Periodic work, you provide an ExistingPeriodicWorkPolicy, which support 2 options REPLACE and KEEP. These options function the same as their ExistingWorkPolicy ocunterparts. 
