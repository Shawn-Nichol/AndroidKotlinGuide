## Saving UI States
Preserving and restoring an activity's UI states in a timely fashinon across sytem-initiated activity or application destruction is a crucial part of the user experince. In these cases the users expects the UI state to remain the same, but the system destorys the activty and any state stored in it. 

To brdige the gap between user expectation and system behavior use a combination of ViewModel objects, the onSaveInstanceSTate() methods and or local storage top ersist the UI state across such application and activity instance transitions deciding how to combine these options depends on the complexity of your UI data, use cases for ayour app, and consideration of speed of retrieval versus memory usage. 

Regardless of which approach you take, you should ensure you app meets user expectations with respect to thier UI state, and provides a smooth snappy UI (avoid lag time in loading data into the UI, sespecially after frequently occuring configuration changes, like rotation).  In most cases you should use both ViewModel and onSavedInstanceState()

## User expectations and dsystem behavior
Depending upon the action a user takes they either expect that activit  state to be cleared or the state to be preserved. In some cases the sytem automtaclly does what is expected by the user. In other cases the system does the opposite of what the user expects. 

User-inititated UI state dismissal
The user expects that when they start an activity, the transient UI state of that activity will remain the same until the user completely dismisses the activity. The user can completely dismiss an activty by. 


- pressing the backbutton
- swiping the activity off of the overview (recent) screen
-  navigating up from the activity. 
- killing the app from setting screen.
- COmpleting some sort of finishing activity (which is backed by activity.finish().

The user's assumption in thses complete dismissal cases is that they have permanently navigated away from the activity, and if they re-open the activity they expect the activity to start from a clean state. The underlying system behavior for these dismissal scenarios matches the user expectation the activity instance  will get destroyed and removed from meomry, along with any state stored in it and any saved instance state record assodicated with the activity. 

There are some exception to this rule about complete dismissal for example a user might expect to a browser to take them to the exact webpage they were looking at before they exited the browser using the back button.

## System-initiated UI state dismissal
A user expects an activity's UI statte to remain the same throut a configuration chagne, such as rotation or swithing into multip-window mode. However, by default the system destorys the activity when such a configuration change occurs, wiping away anay UI stae stored int eh activity instance. To learn morea bout device donfigurations, see the configuration reference page. Note, it is possible to override the default behavior for configuration changes

A user also expects your activity's UI state to remain the smae if they temprorarily switch to a different app and then come back to your app later. For example, the user performs a search in your search activity and then presses the home button or answers a phone call -when they return  to the serach activity they expect to find the searhc keyword and results still there, exactly as before. 

In this scenario, your app is place in the backgorund the system does its best to keep your app process in memory. However, the sytem does it sb est to keep your app processs in meomry. However, the system may destory the application process while the user is away interacting with other apps. In such a case, the activity instance is destoryed, along with any state store in it. When the user relaunches the app, the activity is unexpectedly in a clean state. Lo learn more about prodess death, see Process and Application LifeCycled. 

## Options for presvering UI state. 
When the user's expectations about UI state do not match default system behavior, you must save and restore the user's UI state to ensur ehtat the system-initiated destruction is transparent to the user. 


                            |        ViewModel          |     Saved instance state      | Persistent Storage. 
Storage location            | In Memory                 | serialized to disk            | on disk or network
survivies config chagnes    |  yes                      |       yes                     |       Yes
Process Death               |  no                       |       yes                     |       yes
Survives activity dismissal |  no                       |       no                      |       yes
Data Llmiitation            | complex object are find   | Only for primitive types      | Only limited by disk space
                            |  but space is limited by  | and simple, small objecs      | cost / time of retrieval from
                            |   available memory        | such as strings               | the network resource
                            |                           |                               | 
Read/write time             | Quick memory access       | Slow requires                 | slow (requires disk access or 
                            | only                      | serializatin/deserialization  | network transactions
                            |                           | and disk access

## Use ViewModel to handle configuration changes. 

ViewModel is ideal for storing and managing UI-related data while the user is actively using th e application. It allows quick access to UI data nad helpls you avoid refetching dat from the network or disk across rotation, whindow resizing, and other commonly occuring configuratino changes.

ViewModel retains the data in memory, which means it is cheaper to retrieve than data form the disk or the ntwork. A ViewModel is associated with an activity (or someother lifecycleowner) it stays in meommry during a configuration change and the system automatically associates the ViewMdoel with the new activity instance that results from the configuration chagne. 

ViewModel are automatically destoryed by the system when your user backs out of your activity or fragment or if you call finish() , which means the state will be cleared as the user expects in these scenarios. 

Unlike saved instnace state, ViewModels are desotyed uring a system-initiated process death. This is hwy you should use ViewModel objects in combination with onSavedInstanceState or someother disk persistence, stashing identifiers in savedInstanceStae to help view models reload the data after system death. 

If you already have an in memory solutiion in place for storing your UI stae across configuration chagnes, you may not need to use ViewModel. 

## UseonSaveInstnaceState as backup to handle system-initiated process death. 
The onSavedInstanceState() callback stores data needed to reload the state of a UI controller such as an activity or a fragment, if the system destorys and later recreates that controller. To learn how to implement saved instance state see Saving and restoryi8ng activity state in the Activity LifeCycle guide. 

Saved instance state bundles persist both configuration chagnes and process death, but are lmiited by amount of storage and speed becuase onSavedInstanceState() serializes data to disk. 
Serialization can consume a lot of memory if the objects being serialized are complicated. Becuase this process happens on the main thread during a configuration change, serialization can cuase dropped frames and visual stutter if it takes too long. 

Do not use store onSAvedInstanceState() to store large amounts of data , suhc as bitmaps, nor complex data structures that require lengthy serialization or deserialization. Instead, store only primitive types and simple small objects ushc as String. AS such, use onSAvedInstanceState to store a minimal amount of data necessary, such as na ID, to re-crete the data necessary to restore the UI back to its previous state should the uother persistence mehcansisms fail. Most apps should impleemtn onSavedInstnaceState to handle system-initiated proccess death. 

Depending on your app's uses cases you  might not need to use onSavedinstate at all. For exmpel a browser might take the user back to the exact webpage they were lookign at before they exited the browser. If your activity behaves this way, you can foego using onSaveInstnaceState() and isntead persistet everyting locally. 

Additinoaly, when you opena an activty from an intent, the bundle of extras is delivered to the activity both when the configuratino changes nad when the sytem restores the activity. If a piece of UI state data such as search query, were passed in as an intent extra when the activity was launched, you could use the extras bundle instead of the onSAvedINstanceState() bundle. To learn more about intent extras, see Intent and Intent filters. 

In either of these scenarios you should still use a ViewModel to avoid wasting cycles reloading data from the database during a configuration change. 

In cases where the UI data to preserve is simple and lightweight, you might use onSAveInstnaceState() alone to presever your state data. 

## Use local persistence to handle process death for complex or large data
Persistent local storage, such as a database or shared preferences, will survivie for as long as your application is installed on the user's device (unless the user clears the data for your app). While such local sotrage survives system-initiated activity and application process death, it can be expensive to retrieve becuase it will have to be read from local storage in to meomory. Often this persisten local storage may already be a part of your application architecture to store all data you don't want to lose if you open and close the activity. 

Neither ViewModela nor saved instance state are long-term storage solution and thus are not replacemtn for local storage, such as a database. Instead you should use thsee mechansisms for temporarly storing transisent UI state only and use persistne sotrage for other app data. See Guide to app architecture for more details aobut how to leverage local storage to persist your app model data long term

managing UI State: Divide and conquer. 

You can efficiently save and restore UI state by diving the work among the various types of persistence mechansisms. In most cases, each of these mechansisms should store a different type of data used int eh activity, based on the tradeoffs of data complexity, access speed, and lifetime. 

- Local persistence: Stores all data you don't want to lose if you openand close the activity. 
  - example a collection of song objects which could include audio files and metadata. 

- ViewModel: Stores memory all the data needed to display the associated UI controller. 
  - Example: The song objects of the most recent serach and the most recent serach query. 

- onSaveInstanceState: Sotres a small amount of data needed to easiliy reload activity stae if the system stope and tehn recreates the UI controller. Instead of storing comples objects here, persist the complex objects in local storage and store a unique ID for thses objects in onSaveInstanceState()
  - Example: Storing the most recent search query. 
  
As an example cconsider an acitivty that allows you to search through your library of songs. Here's how differen events should be handled

When athe user adds a song, the ViewModel immediately delegates persisteing this data locally. If this newly added song is omething that should be shown in the UI, you should also update the data in the ViewModel object to reflectthe addition of the song. Remember to do all database inserts off the main thread. 

When the users earches foa song whatever complex song data syou load from the database for the UI controller should immediately stored in teh ViewModel object. you hsould also save the search query itself in the ViewModel object. 

When the activty goes into the background, the system calls onSAveInstanceState(). YOu should save the serach query in the onSaveInstanceState() bundle. This small amount of data is easy to save. It's alos all the information you need to get the activty back into its current state. 

## Restoring complex states: reassembling the pieces

When it is time for the user to return to the activity, there are tow possibel scenarios for recreating the activity. 

- The activity is recreated after having been stopped by the sytem. The activity has the query saved in a onSAveInstanceState bundel, and should pass the query to the ViewModel. The ViewModel sees that it has no search results cached, and elegates loading the serach results, using the given search query. 

The activty is created after a configuration change. The activity has the query saved in an onSAvedINstnaceStae Bundel, and the viewmodel already has the serarch results cahced.. You pass the query from the onSaveInstanceStae()) bundle to the ViewModel, which determines that it already has loaded the necessary data and that it does not need to requery the database. 

